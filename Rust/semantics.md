# Semantics

Rust 学び直しをしている際にイメージしづらかったのでメモをとることにした。

## 前提

Rust において、メモリ上に確保された値には所有者（所有権をもった変数）が設定される。

所有者、所有先の値には以下のルールが有る

- それぞれの値には、あるライフタイムを持ったただ1つの所有者がいる
  - 所有者のみが、その値にアクセスできる
- どの値の所有権も持たない変数は「未初期化状態」になり参照できない
- 所有者のライフタイムが終了するなど、所有者がいなくなった値はメモリ上から破棄される

## コピーセマンティクス

- 既存の変数を新しい変数と `=` で結びつけたときに、新たなメモリ領域が確保されて、既存の変数の値をその領域にコピー
- 既存のメモリ領域の所有権は既存の変数が持ち続ける
- 新たなメモリ領域の所有権は新しい変数が持つ
- 変数型が `Copy` トレイトを実装している場合に起こる

コードを交えながら説明すると以下のような感じ。

```rust
// 1 の値がメモリ領域に確保される
// 変数 s はそのメモリ領域を所有する（ s は 1 の所有者）
let s = 1;

// ここで s の値を別のメモリ領域にコピーする 
// コピー先には同じ値 (1) があるが、s と t はそれぞれ異なるメモリ領域を所有する
// コピー元の 1 は引き続き s が、コピー先の 1 は t が所有する
let t = s;

// コピー元の 1 の所有者は s のみ
// なので、 println! は動く
println!("{}", s) 

// 同様に、 コピー先の 1 の所有者は t のみ
// なので、 println! は動く
println!("{}", t)
```

## ムーブセマンティクス

- 既存の変数を新しい変数と `=` で結びつけたときに、既存の変数の持っていた所有権が新しい変数に移動
  - 既存の変数は所有権を失う
- メモリ領域は新たに確保されない
- 変数型が `Copy` トレイトを実装していない場合に起こる

例えば、String 型は `Copy` トレイトを持っていないので、以下のように書くとエラーになる。

```rust
let s = "hello".to_string();
let t = s; // ここで所有権が s から t に移動する

println!("{}", s); // s はどの値の所有者にもなっていないので、参照できない（なのでここでエラー）
println!("{}", t);
```

## 感想

プログラミングにおけるセマンティクスとは、「コードが何を意味し、どのように動作するか」を指すらしい（ChatGPT 曰く）

例えば以下のコードだと、「`x` に値 `8` が割り当てられる」という意味（及び動作）を指すことになる。

```rust
let x = 5 + 3;
```

Rust にはの2種類がある。

前述した意味に沿ってコピーセマンティクスとムーブセマンティクスを考えると、

- コピーセマンティクス: 値の所有権が s から t にコピーされる
- ムーブセマンティクス: 値の所有権が s から t に移譲される

といったところだろうか。こう考えるとすんなりイメージできる。

所有権の借用とか考え出すと、`s.clone()` みたいな形でコピーしたり `Copy` トレイトを実装すればと思った。でもこれはメモリコピーが無駄に発生する事になって、ムーブセマンティクスの利点を潰してしまうらしい…。確かに🦀…。

## 参考

- [コンセプトから理解する Rust](https://gihyo.jp/book/2022/978-4-297-12562-2)
  - P.59 ~ 63