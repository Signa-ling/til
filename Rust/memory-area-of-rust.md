# Memory area of Rust

メモリ領域については[こっち](../memory/memory-area.md)に記載

ここでは Rust におけるメモリ領域についてを記載する


## 静的領域に置かれるもの

`static` が該当する。

```rust
static FOO = 1;

fn main() -> {
    static BAR = 2; // 関数内でも使える 
    // 中略
}
```

`static` 宣言した値はプログラム実行の最初から最後までメモリ上に存在する。

そのため、 `&` によるリファレンスが使える。（後述する `const` だとこれができない）

##　スタック領域に置かれるもの

コンパイル時にサイズが決まっている値しか置けない。該当するものだと、関数内で `let` で変数に束縛された値が該当する

```rust
fn main() -> {
    let sample = 1;
    let array_sample = [1, 2, 3];
}
```

また、配列のスライス（`[T; N]`型）についてはざっくり以下のような情報をスタック領域に持っていることをイメージしておくと分かりやすそう。

```rust
// あくまでもイメージ
struct ArraySlice<T> {
    ptr: *const T, // 先頭要素が格納されているスタック領域のアドレス（生ポインタ）
    len: usize // スライスした際の要素数
}
```

ちなみに、このような生ポインタと補助的な情報をあわせた構造を、ファットポインタ (fat pointer) というらしい。（逆に生ポインタしか情報がないものはシンポインタ (thin pointer)というらしい…。）

つまり、以下のようなイメージ

```rust
fn main() {
    // 0, 1, 2 の値はスタック領域に置かれる
    let array = [0, 1, 2];

    // array_slice は先頭要素 1 のアドレスとサイズ 2 の情報をスタック領域に保持
    let array_slice = &array[1..];
}
```

このような情報量にすることで、実データのコピーが不要であることや、大きい配列を扱う場合でも余分なメモリ消費やコピー処理にかかるコストを小さく出来る。

## ヒープ領域に置かれるもの

`Vec<T>` 型や `Box<T>` 型がある（他にもあるかも）

```rust
fn main() -> {
    let mut vec_sample = vec![1, 2, 3];
    let box_sample = Box::new(1);
}
```

`Vec<T>` の構造体の本質的定義は配列のスライスと同様である

```rust
// あくまでもイメージ
struct Vec<T> {
    ptr: *mut T,
    len: usize
}
```

配列のスライスとの違いとしては、`ptr` の示す先がヒープ領域に動的確保されたメモリの先頭アドレスであることくらい。

また、`Vec<T>` のスライスについても同じである。つまり、以下のようなイメージ

```rust
fn main() {
    // ヒープ領域には値 0, 1, 2 がある
    // スタック領域には以下の2つがある
    // - ヒープ領域に格納された先頭要素（0）のアドレス
    // - サイズ（今回は要素3つなので3）
    let v = vec![0, 1, 2]

    // 以下の2つをスタック領域に保持
    // - ヒープ領域に格納された先頭要素（1）のアドレス
    // - サイズ（要素が2つなので2）
    let v_slice = &v[1..]
    // 
}
```


`Box<T>`型は、`let` で束縛するとスタック領域に置かれてしまう値をヒープ領域に置くために用いる。

`T` のサイズが決まっているかどうかでメモリレイアウトが変わる。

サイズが決まっていれば、 `T` の生ポインタだけを保持したもの（thin pointer）になる。

```rust
// あくまでもイメージ
struct Box<T> {
    ptr: *mut T
}
```

サイズが決まっていないもの…例えばトレイトオブジェクト（dyn Trait）だと以下のようなファットポインタになる

```rust
// あくまでもイメージ
struct Box<dyn T> {
    data_ptr: *mut (), // 実際の型データの先頭アドレス
    vtable_ptr: *const (), // メソッドや型情報などへのポインタ
}
```

## その他

`const` は定数宣言であるが、値をメモリ上に配置しない。そのため、 `&` を使ったリファレンスが作成できない。（これが冒頭の `static` との違い）

またこの特徴から、メモリ上においた値を参照するよりも高速動作が見込める。

```rust
const FOO = 1;


fn main() -> {
    const BAR = 2; // 関数内でも使える 
    // 中略
}
```

## メモ

- dyn Trait がちょっとまだ理解できてないので、 `Box` のイメージがついてないかも


## 参考

- [コンセプトから理解する Rust](https://gihyo.jp/book/2022/978-4-297-12562-2)
  - P.160 ~ 167